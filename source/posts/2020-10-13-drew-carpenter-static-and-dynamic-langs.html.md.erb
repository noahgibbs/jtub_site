---
title: "Drew Carpenter: Static and Dynamic Languages"
anchor_fm_embed: With-Drew-Carpenter-Static-or-Dynamic-Languages-ekqu41
episode_image: 
quick_summary: "In this episode, Drew and I talk about job interviews, static and dynamic languages and a little of everything career-related."
---

Note: this isn't a complete transcript. I'll come back and complete all the show notes after I'm back from my vacation in mid-to-late October.

## Links We Mention


## Transcript

Noah Gibbs  
Hello, this is Noah Gibbs for Computer Science: Just the Useful Bits. I'm here today with professional developer Drew Carpenter, who has programmed in Ruby and in Go, we've met a few times in person. And it's it's great to talk again, you know, virtually as it were, hey, Drew, good to see you. How you doing?

Drew Carpenter  
You as well, doing great, thanks, Noah. I'm glad to be on here.

Noah Gibbs  
All right. Well, there are probably people out there who are wondering, this Drew guy? How'd he learn to do what we do? How did you learn to be a developer? So can you tell us a little about that?

Drew Carpenter  
Absolutely. So I think my really my real education, educational history, it's pretty varied. There were parts of probably the more traditional route. Started off, majored in computer science in college. So you know, have a... have a bachelor's in computer science from there. But I think really, really, for some of the stuff I use day to day is really stuff that was self taught or picked up, like, outside of school. So of course, I think, you know, being able to get your hands dirty, or you know, get your feet wet with all the different fundamentals and you know, pick up on all that can be super helpful, but it really wasn't until like, after, it wasn't until after, after I graduated that I'd happen to have some other friends that had won a venture competition, they were trying to, you know, get a startup off the ground, and some other friends that happen to... happen to have chosen Ruby on Rails to help get that off the ground. And, you know, I'd wanted to be part of it. So it's like, you know, I'm gonna, this is like an awesome, awesome framework, so I'm gonna go and pick this up. And so that's, you know, that was really my first introduction, other than kind of one side project I had, one side project in college. So using different web frameworks. So that was really when I first you know, kind of gotten to the area where I've almost spent most of my career was, you know, picking up Rails to help these other friends. But yeah, so that was that was really the first, you know, other than, you know, picking up Python and stuff for an internship I had outside that was pretty traditional. B, I think there was also, you know, lots of other different areas that... or sites and tools, I was able to help leverage to learn and further education. You have a cliche, of course, StackOverflow, especially in the earlier years was invaluable, especially if not knowing quite, not quite knowing what question to ask, maybe at times, to be able to have people come in there and help shape up your question or help ask kind of right questions to shape what you're looking for. And of course, you know, tutorials on the internet, you know, blog posts from other people, or, you know, just tutorials in whatever form. Whether it's sites like PluralSight, you know, just kind of can have the more formal ones, of course, or just, you know, whoever's happened to have, happen to have written a blog. And of course, I think another you know, well I'd say probably one of most helpful things, at least for interviewing for me, was a website called InterviewCake. And so that's, it's actually a paid site, but I happen to have... happen to have had another friend. Yeah, short of it, it happens to be a paid site. But like, I feel it... like how well curated some of the questions and exercises on there and like, the way they tend to kind of walk you through different approaches, different nuances of, you know, styles of algorithms to apply to different scenarios, things that have been extremely helpful. And of course, you know, there's all the different exercises you can do on websites like HackerRank, CodeFight, you know, Exercism is obviously pretty really great, too. I think I think InterviewCake especially. And I would say it, of course, depends on, you know, what your goals are, and what sort of problems you're attempting to, you know, want to work on. But especially for the more algorithmic stuff, Interview Cake was invaluable.

Noah Gibbs  
So I'm actually, that's, I mean, that's great. That's all really useful. And obviously, I'm in favor of, you know, paid training, I sell it. I'm not as interested in the interview preparation as the... what you found useful on the job, though. For most of this, what I'm really curious about is what it's actually like to write. A lot of the folks out there listening, you know, they... they're looking at how much computer science to study, how much to do, what to... what to do. Do they take a bootcamp? Do they take a traditional four year university, you know, degree, and the question is not so much what's good in an artificial setting. Because I mean, they're looking at an artificial setting, right?

Drew Carpenter  
Sure.

Noah Gibbs  
University is an artificial setting, but the interview kind of is too. What you and I talked about earlier, as our, as our, you know, topic in advance was static and dynamic language trade offs, and perhaps SOLID-type object oriented design principles. So let me ask you a question. When I read this list, I love everybody's lists. And I love everybody's lists. Yeah, I went to college a long time ago. And so what we studied in a computer science degree was different in, you know, I graduated in '98. Did you actually study the solid design principles in university?

Drew Carpenter  
I did not. Yeah, so that was definitely more invaluable set of principles I picked up post college.

Noah Gibbs  
Well, that's, that's valid. Absolutely. That's still theory, right? That's absolutely, I was just curious, because, man, if they're teaching those in college, in university now, like, that's a, that'd be different. They probably are.

Drew Carpenter  
Right. Yeah. I wonder. So, you know, that's actually like, design principles was definitely one of the thing. One of the things that I you know, picked up later in terms of and of course, you know, general data structures and algorithms and stuff. So, I have a design pattern in that sense, but you know, overall, that's, you know.... you know, object oriented design patterns get whether just Gang of Four patterns or what just wasn't something that happened to come up, at least that I recall,

Noah Gibbs  
Which is kind of weird looking back on it because universities are so focused on trying to find something that feels like theory to focus on and to teach. And I don't know, I would have thought the Gang of Four patterns would be something they just pounce on, but it doesn't

Drew Carpenter  
Oh, absolutely

Noah Gibbs  
seem like it happened.

Drew Carpenter  
Absolutely.

Noah Gibbs  
And in the same way, static versus dynamic languages, they never said that when I was in university, but they did have some static languages and some dynamic languages they taught, I don't remember them kind of focusing on that, as theory. Was that a thing that you did some of in university, or was that after university?

Drew Carpenter  
So, so a little bit of both the school I'd gone to, they'd happen to focus on C++ as their learning language. And I think lots of the reasoning was, you know, we're going to teach you as much of the fundamentals as possible, you know, whether it's memory management, you know, having to manage pointers, you know, all these things. And I think that's one of the more interesting aspects, though, because in terms of what I've happened to us later in life, honestly, I think, you know, whether it was Python, or Ruby, or some other, you know, high level interpreted language that could have... could have helped probably maybe as more starter language. Not in the sense that I think c++ couldn't be useful in other contexts. But in terms of what I think is most sought after in the marketplace, I mean, of course, there are areas looking for the more extreme optimization and looking for, you know, depending on... depending on your goals as a company, and you know, how, you know, of course, you know...

Noah Gibbs  
A device driver company is not going to let you do it in Python, regardless. And yeah.

Drew Carpenter  
For sure, for sure. But honestly, yeah, it was interesting, because I didn't seem, at least when I came out of college, I hadn't felt as I, I don't know, if I was excited as... excited about diving into, you know, a project where I'm necessarily using C++, it's not the sense of like, whatever challenges, I think there's just something about, you know, at least after I graduated diving into like the startup world, I'll be able to iterate really quickly and get products to market really quickly. And I think that's what really excited me about Ruby on Rails is just the speed of iteration. And you didn't have to do as many things. Now, of course, later, you know, later on, I've come to really appreciate statically typed languages even more so. Yeah, I think that's something I've often thought about, you know, if it could have been more helpful to have it, you know, Python or Ruby as a starter language. And then you know, if you wanted to get into more like advanced system optimization, or different areas, like you're saying and more hardware stuff, or what. You know, maybe have the option to dive into that. Yeah, yeah. So that was that. Yeah, there was definitely other than an internship I had where they were... I was building an interface... Desktop interface for for Linux for system, bioinformatics software. That was only real time my first experience with interpreted language was Py-, picking up Python for that. So but outside that C++ and some one-offs with Objective C, C, some Java. C++ was the learning learning language in that context.

Noah Gibbs  
That makes sense, I would even to riff on what you said about maybe a good idea to learn Ruby or Python first, which I absolutely agree with. I think that's great advice. Even if you did learn a statically typed language first, I'd like to kind of draw... draw a dotted line in between static languages, things like C and C++, and even Java to a lesser extent, that tend to tie you down to very exact data types, versus a statically typed language. The extreme examples or something like ML or Haskell, you know, the really academic ones, but, but even, even something like Java, where you declare how you use things to the language, and the language is good about enforcing them. Because I think both a dynamic and a statically. typed language can be a solid thing to learn in. But a systems language like C or C++, I mean, I, I'm biased... Assembly for that matter, which was one of the early ones I learned or basically...

Drew Carpenter  
They had assembly too, they had that one too.

Noah Gibbs  
Like, none of those are as good as a proper dynamic language, where you've got a lot of freedom to do interesting things, or a statically typed language that will at least tell you when you're doing it wrong. I absolutely agree with you. But I want to sort of underscore that, as picking a statically typed language to learn control goes, C++ is actually a terrible example. I wasn't a huge fan of it either. Like I loved C and I still hated C++.

Drew Carpenter  
Yeah, obviously, C extensions for the language like Ruby, languages like Ruby and other ones that support that is definitely however exciting, though, you know, in the right context. For sure.

Noah Gibbs  
So, um, we talked about, you know, differences, trade offs between statically and dynamically typed languages. Is C++ the primary static language you're used to using? Or have you used any of the ones with kind of a more powerful type system? There are a lot of languages with -- in different ways -- a more powerful type system.

Drew Carpenter  
Sure. I would say, so, Go's become, yeah, what I most... What, what's in terms of, in terms of statically typed languages or whatnot. So yeah, I'd say C, I mean, C++. I mean, I did used it however much in college, for sure.

Noah Gibbs  
No, Go is, Go is much more of a statically typed language than c++. Definitely.

Drew Carpenter  
No as an aside? Okay. So I'm definitely using the right term. Okay. So the statically typed, and there's so what's, what's the difference? I should know this. But what's the difference between when we talk about statically typed versus like we're talking about?  

Unknown Speaker  
Yeah, yeah.

Noah Gibbs  
Okay. Well no, you know, you can be one of today's lucky 10,000. And there's nothing wrong with that. You've seen that XKCD, right?.

Drew Carpenter  
I'm not like saying random things. It's like well, good, nothing bad just taking your time. But sounds like there's a subset to subset so

Noah Gibbs  
You're doing great. It's all good. So, really academic languages where you declare your types very exactly, almost as though it was math...? Saying that Haskell is math makes me itch because I have a math degree. And it's really not. But it's almost like math. You're declaring things about what you use and how you use it. And so in Haskell, a really common thing is to declare exactly how many arguments something takes, what types of arguments they take, what it returns, what methods you will call on each of those types. And then once you've done that, you only put them in a few places. And Haskell has full declarations everywhere for all of those things. ML does the same thing. And it basically says, oh, you've used this value here. Well, you gave me these mathematical declarations about this value, which means if you pass it in here, that tells me the type of this the second argument is this complicated thing you just passed, it has to return exactly what you're assigning it to, because you told me exactly what that is to assign it to. And it will think of it as a graph algorithm. It'll spider out over your code with all the assumptions it knows, and guarantee just exactly this takes this argument. This returns this type. It's called the Hindley Milner type system is the specific...

Drew Carpenter  
Okay.

Noah Gibbs  
...is the specific version that ML and Haskell use. And there are variations like OCaml that are a little different, but basically similar, that do the same, do the same trick in a slightly different way. And so that's a static... statically typed language, in the sense that it fully nails down absolutely every value you pass around, at compile time, before you ever get into runtime, just exactly what type everything is. Which in theory lets you optimize just absolutely down to the bits. Because if you know everything about the value, you know exactly what width to pass around, you know exactly what operations are legal on it. But you don't do it C style, where they just trust you to know what you're doing. And you pass around, you know, what's essentially a pointer to a buffer of bits, like in C you do that but the compiler doesn't keep track of it. It just has to trust you to do the right the right thing. And if you do the wrong thing, it blows up.

Drew Carpenter  
Interesting.

Noah Gibbs  
Whereas in something like Haskell or ML, you fully specify all of it, and it comes up with a custom baked representation that will only let you pass the right thing. And you don't directly control the representation. But if you try to pass something you shouldn't, it will have chosen not to let you do that at compile time before it ever starts running the program.

Drew Carpenter  
Interesting. So that's it. So it's a question of like, almost a question of like strictness of the typing system. Like so for instance, like not having variadic functions and stuff like that?

Noah Gibbs  
You can have a variadic function that provided you tell it enough about how to figure out what the variadic function is and how it works.

Drew Carpenter  
So for instance, like, like where Go has like interface, like interface definitions you can essentially do duck typing, would it allows stuff like that even?

Noah Gibbs  
Usually no, usually no. It allows some variations on that. And if you're used to dynamic typing, or most standard languages, they're weird variants on it. So like, it's utterly okay to have one argument which tells you exactly what type of the next thing is. And then depending on the five allowed values of that first thing, here are the five different patterns for it. But you specify it completely. And the kind of thing that you, you're, you and I are used to specifying at runtime stuff in like Ruby or Go... I'll pass this through, and then depending on what the value of the first thing is, I'll do it differently with an "if"? No. Depending on the value of the first thing, you will give it five different compile time choices, and it will pick one of them, and it will have exactly the type signature for that, that you're... that you're going to use.

Drew Carpenter  
Okay, so the terms okay. Statically typed and then static languages. I guess also, like, what I would have considered synonymous, at least in the past would just be like, strongly typed instead. I mean, would you consider those strongly typed, would that be more in...?

Noah Gibbs  
I would say that the statically typed Hindley Milner languages are a subset of strongly typed. They absolutely strongly typed languages, they are they are some of the most strongly typed languages in existence.

Drew Carpenter  
Okay, that's what I was... Okay. But (...)

Noah Gibbs  
You could have a strongly typed language that doesn't take it that far. And you can definitely have a strongly typed language that doesn't have that dynamic solver, where it figures out everything from a small...

Drew Carpenter  
Okay, so maybe use, maybe use the phrase "strongly typed language."

Noah Gibbs  
There you go, yeah.

Drew Carpenter  
Or Yeah, I mean, static languages, like I just use static, static, yes.

Noah Gibbs  
And because developer vocabulary is terrible, and all over the place, a static language usually means one that you compile, which is sort of unrelated to the rest of this.

Drew Carpenter  
This is great, thanks. No, yeah, okay. I'll make sure I'm using it again to make sure I using the right terms, the rest of the podcast.

Noah Gibbs  
Well, it's and the word static is terrible. Because, you know, it's it's a little like, say, what does static man in Java? Well, let me go down the menu because it's about four different things. And they're completely different from each other.

Drew Carpenter  
Okay, cool. I definitely...

Noah Gibbs  
What does static mean in C? Some of the same things, some different things, some completely different. No, we're terrible about how we use the word static,

Drew Carpenter  
Thanks, Noah. I gotta make sure to double check on this before.

Noah Gibbs  
No, okay. All good. So sorry. But in your case, you're thinking about you know, Ruby is a great example of a dynamic language. Ruby is, is one of the most dynamic languages that you'll, you'll see people actually use. And then Go as as more of a static language. So again, some of those strictly typed like static, static, people will argue with them, but you can always find somebody to argue. I said, Ruby is one of the most dynamic languages ever and the Eiffel people would come down on me like a ton of bricks except you can't find them. So maybe maybe they'll leave nasty comments. We'll see. You know, there's there's... it's a spectrum right? You're never... You're never all the way to any end of the spectrum, because there's somebody out there who's at least thought of a way to do it more so. Yeah, but tell me about those differences, as you've observed, as you've played with them, as you've learned, we're talking about education, you know?

Drew Carpenter  
Yeah, absolutely. So I think, I think for me, where it starts in terms of attempting to audit the differences beside what's, you know, in terms of, you know, auditing the differences and assessing, you know, what tool would be right for the job? So I think the first question is, you know, what tools are right for the job? And then that can drive, you know, what aspects of different languages will be most helpful. And so it's been in different cases, you know I've discovered what's been most helpful. Obviously, the dynamic nature of Ruby, you don't have to spend time typing. And, you know, it's duck, you know, duck type, does it respond to this? Well, it may fail when, you know, may fail when it's being interpreted. No, you never know. So I think it's, I think it's a lot of the question of how much time you want to invest in, invest in things. And you know, what's the ROI? So I think, at least within the business perspective, it's a lot about what your goals are, as a business, you know? Your tiny startup, who doesn't have much time, you got to test your, you got to test your product market fit really quickly, adjust really quickly. You don't have that... You don't you don't have the buffer to be able to sit there and say, Well, you know, we have, you know, 10% speed increase but only five users, or 50% speed increase but only five users. So like, you know, what, what benefits are reaping? Let's say, you get, like, Google scale, or you're looking at tons and tons of data, I think there are cases like, you know, you have millions and millions of users, and you're shaving these shaving the seconds, or however many microseconds off these calls, you're able to save however much money, you know. You're able to, you know, it just really gets blown up at scale. I think there's lots of things, I think, you know, for startups, and oftentimes, you know, whether it's prototypes if you're looking to, you know, build and iterate really quickly? Interpreted languages are the way to go, I think. If you're looking for like, true reliability and extreme optimization: static languages. And obviously, like, you're saying, there's a spectrum. So you know, how, how reliable do you want it to be? How strongly typed and how strictly typed, do you want it to be? So yeah, I mean, I think there's lots of advantages, you know. I think one of the biggest things... And I know, like, for instance, you can set this up in Ruby, you can set this up in Ruby. But you know, just being able to have be able to go into your ID as this is a very minor thing. And something I started missing the other day, when I went to doing the Python script, I shouldn't have it set up. But, you know, IntelliJ, and stuff like that, you know, out of the box, it's tracing through all the different libraries, and, you know, simply here all the different methods you can do, you can use for given function, you know, here's everything it takes. Just basically, you know, have the annotations on all the things. Of course, you can generate that with, like solar graph out of different language servers and stuff. But I know, at least personally, like, yeah, that was a bit more interesting, in the Ruby world than, you know, out of the box that lends itself to, you know, stuff like that. So I think they're a little bit... There are, like, you know, productivity, you know, efficiencies in terms of development that come along with that kind of stuff, and be able to help unlock that kind of stuff and make it a bit more easy for whoever's developing the tools, you know, to have that kind of stuff out of the box. So, I mean, you've also got setup costs, but yeah, I mean, I think, you know, just reliability and extreme optimization - static languages. In a build and iterate very rapidly - interpreted languages. And then, but, at the end of the day, you know, what are your goals? And what, you know, what are your design goals? And you know, rippling those and deriving those from the goals of the company.

Noah Gibbs  
You said something that I found interesting, and I'm not sure I caught it. So if you hear me saying anything that sounds wrong, tell me so and that means I was wrong. You're talking about the IDEs. And I assume, again, this is Go versus Ruby. My experience is that Ruby IDEs are not the most capable things in the world. Partly Ruby's very dynamic. Like, it's genuinely hard to do that with a dynamic language like Ruby or JavaScript, you know, half of your... if half of your methods usually get generated at runtime, like in ActiveRecord, like, there's only so much an IDE can do with that. My assumption would have been that Go would have an easier time with an IDE because it's less static than Ruby, like, again, everything else. Is that what you were saying? Or was it the other way around?

Drew Carpenter  
Okay, sorry. Yeah. So Go? Yeah, Go, definitely Go definitely lends itself more so to having all the annotations for sure.

Noah Gibbs  
That makes sense. 

Drew Carpenter  
Absolutely. Yeah. Yeah, absolutely. On to other stuff like Ruby. I mean, Ruby IntelliJ. It has Ruby Mine, the IDE.

Noah Gibbs  
Yeah, but I mean, it's harder to do well, in Ruby.

Drew Carpenter  
Oh, absolutely. metaprogramming stuff, you know, I I doubt that anyone is handling method missing calls. You know, I doubt anyone's handling those.

Noah Gibbs  
You know, what I say about that is... As much as it pains me to say it as an old time developer with the sort of knee jerk reflexive distaste for Microsoft, that people my age... Developers, my age tend to have... If anybody is going to write a first class Ruby IDE that handles that kind of thing well, Microsoft is going to do it first. And the reason for that is because if you look at the VS Code support for JavaScript, they're fixing that problem for JavaScript and nobody else is.

Drew Carpenter  
Oh, really?

Noah Gibbs  
Yeah. They say they essentially interpret your program forward in order to find out the early methods that you define there, which is a really hard trick. But if they can do it for JavaScript, and nobody else is doing it at all, that suggests if anybody was going to come out with a really first class... with really first class Ruby support for their IDE, Microsoft's probably going to be first. Because they already solved that problem. And that's our big problem.

Drew Carpenter  
That'd be great. For sure. Yeah. I mean, that's this have an idea. I have happened to use VSCode more so than Ruby Mine ever. After having, you know, dove into the IntelliJ products a little bit more, I guess I might have gone with Ruby Mine out of the box potentially. Yeah, like shouldn't that, I'll have to look out for that. But that's definitely definitely exciting to be able to have even...

Noah Gibbs  
It hasn't happened yet, not for, not for Ruby. It's just that's what you would need, and they can do it.

Drew Carpenter  
I'lll look out for it happening for Ruby for sure.

Noah Gibbs  
So a lot of what you're talking about with those trade offs, you know, you talk about getting a feel for it. To me, the way I interpret that is that sounds like stuff that you learned on the job mostly, and that you just you get through experience and repetition. Is that what you were saying?

Drew Carpenter  
Absolutely, absolutely. It is stuff I would have never thought about coming out of, coming out of school ever. I think that's one of the biggest things. And actually, as an aside thing it reminds me I think the first time I'd ever happened to meet you at a conference, I think afterwards, I came and asked you, you know, like, what's the one thing I need to focus on? You know, at the time, I was gonna, I'm gonna ask this guy Noah, you know, he'll have an ultra-wise answer. He'll know. And I think, you know, I think you responded, you know, providing value and or do something, you know, that provides meaningful value or something to that effect.

Noah Gibbs  
Well, if you give me an open ended question, like, what's the one thing I need to concentrate on? I'm gonna give you a, you know, vague sounding answer like that. But like that question, it's not as vague as it sounds.

Drew Carpenter  
You can give more specifics. But I think it highlights, just... Rooted in pragmatism, you know, and I think coming out of school, it was, you know, what's right versus what's best having that distinction, I think, what is what was best has changed for me over time for sure for the problem. So I think what was right was best coming out, let's say right, in the sense of, you know, in a vacuum, in theory, you know? Not having to respond to market pressures not you know, not having to worry about sure not have to you know, so you know would come out come out of school and Encino watch engineers ultra, you know, it can be hover over engineer solution, but it's like, well, on theory, this is, you know, this is a simplified as possible, and bla bla. And so I think it wasn't really till later in my career that I really, you know, it became a question of what's the ROI, you know, I don't need to have this fancy abstraction, I'm never, there's not ever gonna be any churn, I'm not gonna able to reap the benefits. Like, if I'm gonna invest more time up front doing this, building this out, however, strongly the coupling it, I, you know, want to ensure you're able to come back and actually leverage that in some sort of way. You enforce it all like things like, rule of three, all these different, you know, all the,

(Incomplete transcript - I'll come back to it after my vacation!)
