---
title: "Tyler Williams: Hands-On Teaching Between Students; the Difference Between Formal and Informal Teaching"
anchor_fm_embed: With-Tyler-Williams-Hands-On-Teaching-Between-Students-Formal-and-Informal-Teaching-eitt1f
episode_image:
quick_summary: "Tyler Williams talks about what made his education good. He's actually going back after years of development to finish his degree and get a master's degree. Not everything was perfect, not everything was good, but he thinks there are parts you can't easily replace in a formal education."
---

## Links We Mention

* [Ogden Studios](https://ogdenstudios.xyz), Tyler's studio for freelance and open source
* [Tyler on Twitter](https://twitter.com/tylerwilliamsct)
* [Ramit Sethi's I Will Teach](https://iwillteachyoutoberich.com)
* [Amy Hoy's Stacking the Bricks](https://stackingthebricks.com)
* [Theta, Omega and Big O Notation](https://www.programiz.com/dsa/asymptotic-notations)
* [Finite State Machines](https://en.wikipedia.org/wiki/Finite-state_machine)
* [XState](https://xstate.js.org/)
* [MUDs](https://en.wikipedia.org/wiki/MUD)
* [LeetCode](https://leetcode.com/)
* [Reginald Braithewaite, aka Raganwald](https://raganwald.com/)
* [The Gwydion Project at CMU, long ago](http://www.cs.cmu.edu/afs/cs/project/gwydion/docs/htdocs/gwydion/)
* [Steve Yegge's "Rich Programmer Food," a post about compilers](http://steve-yegge.blogspot.com/2007/06/rich-programmer-food.html)
* [Tanenbaum's book on operating systems](https://www.amazon.co.uk/Modern-Operating-Systems-Andrew-Tanenbaum/dp/013359162X)
* [Tanenbaum's book on computer networking](https://www.amazon.co.uk/Computer-Networks-Andrew-S-Tanenbaum/dp/0132126958/ref=sr_1_4)
* [Rebuilding Rails](https://rebuilding-rails.com)
* [Mastering Software Technique](https://software-technique.com)

## Transcript

Noah Gibbs: Hello, I'm Noah Gibbs. And this is Computer Science: Just the Useful Bits. I am here with Tyler Williams. And among other things, today, we hope to talk about big O notation and state machines. But I suspect it'll be a far ranging conversation. That's what I like, I get the impression that's what he likes. And I know that's what a lot of you want. So Tyler, tell me a little bit about how you learned computer programming. I mean, that could be University, it could be boot camp, it could be separate classes could be all of the above. Tell me about that.

Tyler Williams: I have kind of a typical trope ish background in computer science. I was a young man in Connecticut, super nerdy and around 12 or 13, got excited about programming. I learned self taught Python and c++ through middle school and early High School, which was super fun. And I think one of the biggest challenges during that time was not having a lot of guidance or practical projects to apply it to. So I wouldn't say that I took a lot of lessons out of there, but it gave me some background. And towards the end of high school, I had a really supportive science teacher who was working at a nonprofit and hired me for a 100 hour contract position to build his nonprofit, an iOS app. So I learned Objective C in, like, 2011. And I used it one time, built an iOS app that last I checked was still in the store, which is kind of cool. It was just like an internal thing for them. They did research. And so after that, I went to college. I went to the University of Connecticut. I majored in computer science for three years. I did the freshman, sophomore, junior year courses for computer science engineering at UConn, and then I did a sharp turn, took a detour. I switched my major to history. I became really disaffected by the university's program, their, you know, educational program. I didn't like my professors, the courses. I was doing fine in my grades. But I struggled a lot with the idea that being at a an institution of learning in a class thinking about engineering curves, right? The idea that everyone in the class would get a 40% or a 50% on an exam, but the curve would bring us up to B's and A's. And it really didn't click with me that you have this source material and you want us to learn most or all of it. But if you're telling us that 40 to 50% is acceptable. The professors and the TA is are disincentivized from helping us fully understand it, or perhaps the scope of the class is incorrect. And so during my time as a computer science student, I had been taking a minor in women's studies and so I had the opportunity, I was able to switch to a history major and still graduate on time. I had gotten involved with some on campus activism. And so I took a detour in my career path. And I ended up working in politics right out of school, got a job, right out of college, moved to DC, moved to Denver, and then did politics for three and a half years. But because I knew tech, I was the tech guy. And I ended up building a lot of web applications for the nonprofit. And I self taught myself back to web development. And that's where I am now doing full stack web, built with Ruby on Rails, Vue.js and react.

Noah Gibbs: So yeah, I've got kind of the classic all-the-programming and nothing else path where I took the computer science degree, I got into programming. I've never really had a real job. I've only had programming jobs.

Tyler Williams: Yeah, that's how I feel about programming as well. I love it and you know, I found I really enjoy, I get a lot of satisfaction out of working in politics, and doing change work. That was great. But when I got the opportunity, you know, throughout my career there, I built tools for us. And that was the most fun I had on the job. Like, I got really excited about finding my way back from the detour. And I'm actually Friday is my first day of classes, enrolled as a master's in software engineering at Regis University here in Colorado. So I'm going to go back and finish the formal education. my opinions about education and its function have kind of matured and evolved and I'd like to sort of close that chapter. So working on completing a formal computer related degree,

Noah Gibbs: Nice. And you're, you're completing an undergrad degree, or...?

Tyler Williams: It'll be a Master's. So okay, software engineering. Yeah, I'll do it part time with work.

Noah Gibbs: Cool. That was going to be my next question, was "part time or full time?" Sounds good. Well, I hope that goes well. I hope you'll let me know how it goes. I always feel a little weird about a master's degree. I don't actually wish I went back and got a master's degree. And I really don't wish I had just stayed and gotten a master's degree at the end of my education when I did it.

Tyler Williams: Yeah.

Noah Gibbs: But every so often I look at that I go I, there's, there's all this stuff I don't know. And then I think I could set aside the time I could self study, and I do, you know, but I don't..

Tyler Williams: it's nice to have the formal training. I think that having someone say, you know, this is the curriculum, and I think this is a lot of, perhaps what we're going to get to today is talking about the value of some of the academic rigor and this idea that, you know, there are pieces of computer science that are relevant to the work that people do when they work in computer science or adjacent fields. And you know, what the value is of having some kind of education, whatever that looks like, right. And, and, and personally, you know, one of the things that I've missed in a lot of my self-teaching is that curriculum of people saying, you know, here's the path here is we're going to lay out like point A to B, and I know that higher education misses the mark in a lot of ways. But I'm excited for the master's program. For me it is really just closing the chapter on... I opened the book on a formal computer science education. I never closed it. I'd like to close it. And the Masters is a good way to do it. But it still moves me forward. I thought about a second bachelor's, but the Masters moves me forward in my career in a way that a second bachelor's doesn't i think

Noah Gibbs: I agree with you. I have two bachelor's and no master's. So I yeah, definitely get where you're coming from.

Tyler Williams: There you go.

Noah Gibbs: So you talk about the you know, the kind of academic rigor and sort of the guiding you along the path. Do you ever pay for non-university type classes? Have you done Udemy or anything along those lines, or I immediately think of like [Ramit Sethi](https://iwillteachyoutoberich.com) and [Amy Hoy](https://stackingthebricks.com/) and other paying for a private lesson? Obviously, I'm not neutral here and I sell a class. But have you tried any of that? Have you found if that gives you any of the same thing?

Tyler Williams: Yeah, no, I think it does. And that's something that I really like about self teaching is that I think especially in 2020 there are more and more easily accessible and affordable resources like that. And those resources are becoming more and more respected which I think is a really important piece of this is, what do other people think about the ways that you learn the things you know? Because I don't think you need a formal education to know things to understand things and to have insight and a working knowledge. But it does matter what other people think about your knowledge so the answer is yes, I bought a Udemy course on React. I bought Rebuilding Rails from you. I heard you on a podcast. I really like the things that you said. I looked you up, saw Rebuilding Rails and was like that's what I need. Bought it, read it, did it. I bought Mastering Software Technique. Still on the shelf. And Jason Swett. I bought his... I started his testing course. Had to leave because I was starting grad school.

And so it was gonna like coincide but I've done a handful of those. And then conferences as well. But yeah, I've definitely paid for a variety of educational materials to sort of go at my own pace, or in one or two instances, you know, purchase some tutor's time for a handful of hours.

Noah Gibbs: Nice. Very few people go that far. But it can be an amazing step for the right topic and the right setting.

Tyler Williams: Yeah, I think it's tremendously valuable. I think it's valuable in a lot of ways. Hands on learning, and this is what I missed. And this is what I think a lot of formal computer science education, and in many other fields as well, anything that happens in a big university. I think there is a huge gap in terms of actual like hands on teaching between people. And that's like one of the things that is I think it's a great way to learn. Universities are not incentivized to do it, because their money tends to come from research, right? If you think of the word and I think of large universities, because that's what I haven't experience with I think smaller schools have a different sort of feel. But I noticed when I moved into the humanities, those folks were much more interested in teaching, right rather than research or their research was teaching and it was more hands on. So, tutors - great way to learn, but also a really good way to like build community and build communal trusts, you know, the more people work with, you know, say like I think of, like respected people in the community who talk and teach, and one on one time with them, you know, builds up this sort of like communal knowledge base, I think that's super valuable, too.

Noah Gibbs: I think in some ways I underrate the place I went to college and their specific attitude of, we're not really going to teach you most of the valuable stuff, but we are going to throw you out if you don't learn it, because it gives a real camaraderie among the students. I mean, one of the joys of being in a place that's incredibly hard working with incredibly smart people that all feel like, Oh, no, they haven't taught us anything. And we're in danger of getting thrown out. You actually get a huge amount of that peer to peer teaching.

Tyler Williams: Yeah, it's it's incredibly important.

And I think that's, you know, those formal systems of education? Well, I think they lack in a lot of ways of the instructors doing that with students. Yeah, they are a great way to get young people or any learner, but typically young people, you know, all together at once in one place in a concentrated place where it's like, Okay, time to learn with your peers, and like time to figure this out together.

I think that's I think that's a really valuable exercise, even if it's challenging, and like, I think they set up some people to fail. I think that's I think that's the case. But like, there's a lot of value out of the good parts of that.

Noah Gibbs: Yeah, again, I really can't disagree with that. Because the place I went to college is unusual in being as highly regarded as it is and having as high rate of people failing out as it does. And again, it's kind of that same approach. It's we're going to accept a lot of people and a whole bunch of you're just going to be bounced out the door.

Tyler Williams: Yeah. And, you know, I just does not click with me and I feel as though like part of me understands the function of prestige and the function of, I mean, there's no better way to say it. Like the weed-out classes, right, I understand how that functions with prestige and like gatekeeping. And like, there's money to be had there because, you know, you build taller gates, that thing that's on the other side becomes that much more valuable. Right. And so that's, that's good for people who are there, regardless of whether or not they like maliciously understand that that's where their interests are. But yeah, I just, you know, I think that, and this was part of why I left the engineering program, because I saw people who were getting weeded out because I was struggling or again, I had a whole class I took a computer architecture course, and I did not take the final, but I got a C on the final, my zero was curved up to a like, 67.

Noah Gibbs: Wow.

Tyler Williams: Right. And so, you know, look, and that was actually the last course that I took, because I said, like, how can you give me a passing grade on this exam, I passed the course and I had done homework, you know, I, but I skipped the final because I I knew I was gonna I was like, very frustrated, and I skipped the final and they passed me with a C on the final itself. And I was like, how can you claim that any person in this course learned the material if you're willing to give me a passing grade for not taking it?

Noah Gibbs: Not showing up?

Tyler Williams: Right, and so and so but you know, broadly, what I think is when people come to you and say, I want to learn, and I'd like to pay money to learn and pay time of my life to learn, I think that is the responsibility of the educators to like, honor that, or if they're not going to honor that be upfront that they will not honor it. And like, be very clear about why, and I can't think of a good reason not to, but if they've got one, I would love to hear it.

Noah Gibbs: Well, I mean, if they were just honest about what they're currently doing, I agree with you, that would be fine. Though I do actually see reasons why they might perfectly genuinely offer that. And in fact, that is the service generally being offered right now. So in some sense, if it's not genuine, then we have a problem. Yeah, I mean, we do have a problem, but in some sense, if that's not genuine, then then that is the problem. But yeah, I agree. It would be very nice if they made it clear, you know which one of those they're doing. I was saying to Jason Swett, who was the guest before you, it's kind of like the lottery right? You can't have a lottery that's awesome for the winners without it sucking for the losers like it has to it has to come from somewhere. And prestige is the same kind of game. It's it doesn't have to be, you know, lottery odds. But if if Carnegie Mellon where I went to college did not toss a bunch of people out, it would certainly be considered less prestigious for those who do in fact, make it through.

Tyler Williams: Yeah, absolutely. And, you know, that's where I think many folks who are part of that or not, may not be doing it maliciously, some, perhaps they are, but like, that's where the interest is, you know, that's where like, that's where it falls, like it's in their interest to continue to do that process. And like build that prestige because they're benefiting from it and they don't have a lot of there's not a lot of force pushing them to stop doing that. And I think that's too bad.

Noah Gibbs: Fair. So to veer off that topic. Yeah, um, you went to about three years of undergrad University, you've done these separate classes and things. How do you feel that's prepared you overall for a software development job? Which bits have been good? Where do you wish you'd learned more? Where do you wish you hadn't bothered and you hadn't spent your time?

Tyler Williams: Yeah. You know, I think about what I do in my day to day work, and what I have done in other similar roles. So now I work full stack web, during college, I worked microcontrollers, dot-Net, industrial machinery. And then of course, a handful, freelance and other flexible kind of programming, right.

And so I think about two types of skills when I'm writing software. The first is sort of just the practical technical literacy. Can I learn a technology well enough to accomplish a task, right? If I, if I've got a script that hits an API and sends an email to someone, you know, can I learn the API can I learn where to run that script? And like how to send emails? Right? So that's the first skill. Is this practical? You know, a lot of it is like DSLs. And it's Michael Hartl talks about technical literacy, and his Rails tutorials and his "Know Enough to be Dangerous" tutorials. And that first skill, the answer is higher education didn't give me any of that. And, you know, they, they teach to a lot of abstract concepts. And it makes sense that they're not going to pick a framework. They're not going to say, "here's Jest." Sometimes they do too, you know, they'll say, here's an example of a testing framework, but usually the examples they choose are 10 years behind the industry. Working at my internship during college, my manager at the time, was always like, I would come back, so I worked for three summers, and two winter breaks. And I'd come back and he would say, what classes did you take? We had a really good relationship. I worked there for a long time. So he knew my coursework. He's like, what classes did you take? I'd tell him and he'd say like, okay, cool, what did you learn in that? I tell him, I show him the syllabus, if I had it or say what book we read, he's like, great, not gonna help you this this time around. And it's just like... and I learned on the job, right? And that's, that's broadly what it's been and my current role, the same deal. I don't think a lot of the things that I learned, practically speaking in college have come with me to web development. And that was one of the challenges too, is I wanted to make stuff during college, and college didn't give me the skills to make stuff. But there's a second part of this, and this is where I think the value comes in. So, so that's technical literacy, technical proficiency, something like that. Right. But then there's this other skill set that matters, and it is a sort of a sensibility. You know, I think wisdom is a heavy word for this, but it is sort of this, you know, like judgment making. Right. And I think the answer there is yes, I think that higher education, formal computer science education, And even all the other pieces, you know, paid for courses are free content on the internet, which I love. And it's great. I think it's one of the best things about the internet is all of the content that is there all the educational material, those things contribute to a better skill at decision making. So I said before, you know, college didn't teach me how to write Python script that would hit an API and send out emails. But it did tell me or teach me and give me some insight into Should I do that, right? Like, what is this? What is the solution? What am I actually trying to solve? Right? Like, like, why am I writing this script? Why am I sending these emails? And like, you know, even more concretely, should I write a script that hits an API and send emails, or should I go buy a product that's $5 a month that will do that for me, and a formal computer science education, you know, if you take a handful of software engineering courses, they'll say, you know, I'd This is the one thing that got drilled in, like more than anything else is, if a solution already exists, use it, right? And there's like a cost benefit analysis, perhaps you can't afford maybe the solution is too expensive for you to afford, then consider building one. But this sort of judgment of like, Hey, you know, something exists, we don't need to spend our time building something, we don't need to open ourselves up to like, unanticipated bugs or vulnerabilities. Like, let's use something that is like battle tested, that sort of thing. I think that computer science education really came through and helped me understand along with those abstract concepts, you know, you think about things like like big O notation, you think about runtime, you think about algorithms. And there's this, this broader idea that I think any education, any very Western liberal arts education gives us this idea that there are good ways to do things, that there are a variety of ways to do things. Some things are better than others. And it is not an exercise in futility to evaluate them and compare them. And that's something that formal education, I think, really imparts is that, like, it is worth your time to look at the whole broad spectrum of things, and make judgments about what you see in front of you and evaluate them. And so, you know, thinking concretely about computer science, I don't think that a lot of software engineers find themselves writing, writing novel algorithms for sorting, right, like, they've probably got a standard library for that. And that's great. They shouldn't write it from the ground up, but they should understand that there isn't an optimal sorting algorithm. Or like sometimes maybe you don't need to write one because, you know, so there's a, you know, you think about the classic example, when people say, oh, is big O notation ever gonna matter? It's people talking about like nested for loops, right, it's like, don't do two for loops, because you're talking about big O of N squared, which is, for those who are unfamiliar is the idea that if you've got two for loops, and you're iterating over your data set, but you're doing a for loop over at once, and then for every item, you're also doing another for loop for, say it's an object with nested attributes, that as your input size grows, as you get more and more top level items, your runtime grows exponentially. It grows at n squared, right? That kind of idea. Yeah, or something like n squared. And so

Noah Gibbs: I'm gonna I'm gonna say here, technically, it's not exponential. In fact, exponential is e^x runtime, right? I like to think of it in terms of doubling. Linear means if you double the input, you doubled the amount of time and quadratic means if you double the input you 4x the amount of time... Okay, I'll quit quibbling.

Tyler Williams: No, but I think it's important. It's important to be precise, one, and it also, you know, it illustrates this idea that, you know, I just said exponential and It's like, wow, like, there's quadratic, and there's exponential. So maybe there's something worse out there. Right?

Noah Gibbs: Yes.

Tyler Williams: So that's the classic example. and computer science tells you like, Hey, watch out, you can make decisions that are gonna be bad, because there is there's a bad option and a worse option. And there's a better option, right? And there's like a good one, there's linear. And so it's good to be familiar with them. I don't think you need to be like, have all of them memorized every single day, but it's good to know that they're out there. And then finally, too, you know, understanding that when we're talking about runtime, and this is something that computer science will will teach this is knowledge computer science education will give you is that like runtime matters. If you have a potentially variable size of data, it certainly matters in static sizes. If it's like a large enough, if you know it's going to be huge every single time. But you know, if you're iterating over, like if you know you're always only going to have 10 items, do your nested for loop because it reads better, right like don't go optimize because like because your time spent optimizing And time spent trying to re-understand your optimization is time wasted, if you're only ever going to have 10 items. And again, this is a piece of information, like a, like a sort of wisdom that computer science can tell you. And so in that sense that education I think is super useful. This idea that there are ideas like a broader range of ideas to think about and evaluate. I think that's useful. But you know, it's not going to tell you how to make a website. And in most jobs, you got to go make a website.

Noah Gibbs: Remind me, where did you go to university?

Tyler Williams: The University of Connecticut,

Noah Gibbs: University of Connecticut, I'm just curious. And when when were you there? Ish, like, what years?

Tyler Williams: 2011 to 2015.

Noah Gibbs: Okay, that's excellent. So I went to university a long time ago, I graduated in 1998. And several of the things that you say sound wonderful to me, because as long ago as that keep in mind, that was before open source was all that common. And most of the time if you could buy a product, it was a giant product, there were only a few, they were hard to find. And so when you say you know, build versus buy, your degree hammered home that you need to consider that you could buy a solution. Wow, that's way better than what I got in university. That's great to hear. That makes me happy.

Tyler Williams: It's cool to think about the evolution of that. That's a Yeah, I had not considered what that would have looked like before. 2011

Noah Gibbs: Oh, you said something else. The quality of decision making and that your input may not grow. And so sometimes the worst big O notation algorithm can still be good enough. That's another thing that I don't feel like my education did a particularly good job growing into me, like, I don't feel like they talked about it much at all. So I'm glad to hear that. That sounds really valuable. And it's better than that I got in my degree, so good. Yeah.

Tyler Willaims: And something to dig into big O. And like that specific idea. If people are listening, and they're interested in big O notation, there's other notations that like deal with ideal datasets and like small data sets. And I forget there's a big data and I forget which one that is, I think that's the ideal data set. And then there's another one First of all,

Noah Gibbs  
There's a little omega, which is the minimum. It looks like a W but it's a lowercase Omega. And yeah, I think [theta is if it is both omega and big O](https://www.programiz.com/dsa/asymptotic-notations). Theta bounds both.

Tyler Williams: Right, yes. Yeah. And so those are really interesting to look into as well. And I think a lot of people get hung up on big O. Because that's what gets asked in interviews, right. And that's what we talk about on Twitter. And like everyone talks about big O. It's also very memorable. I think it's, obviously I remember it better than the, the little omega, right. But there's more there. There's a lot of there's nuance. And I think, you know, that's the value of the computer science education is, let's think about it critically. And then there will be applications, but those applications aren't clear. And I think that's a huge missing gap in computer science education. And it's one that's really well filled by the sort of variety of content that's out there for like self learners. And I think that's, that's really interesting.

Noah Gibbs: Yeah, excellent. Cynically, I would say that big O notation is one of the few times that our profession and its theory veer all the way into actual math. And I think it gets emphasized not just by the people who hear it, but also by the people who are teaching, because it's one of the times that they get to feel like they're imparting math. I mean, so much of what we do when you talk about, do you build it? Do you buy it? You know, how do you express this? It's almost like writing a novel, right? The decisions are the same kind of decisions you make when you're writing English. You're talking about communicating with future programmers, you're talking about a human talking to a human in what's basically a human language. And I always got the impression computer science professors maybe felt that they were not doing what they do, to do that.

Tyler Williams: Yeah, not enough math. Right. And they really want it to be a hard science. And I think you've touched on this. And I think I've heard it in a few other places, that it has come up really only in the last year that I've been exposed to this idea that like maybe programming isn't engineering, right, like maybe software engineering is not an engineering field, because engineering typically, you know, is mass production, where you got to really get it right the first time because you don't get another chance, right? And that's, and that was true of software in some ways for some time. But is I think as time goes on less and less true about software. So I, you know, I think yeah, I think that that is also another challenge in computer science education, is that perhaps the people teaching it have some bias about their self perception, their perception of the subject matter, and they present it in a way that is not 100%, like, what it is, it is not indicative of the nature of the work. And this is again, like I think a lot about, like, I've always excelled in writing courses and humanities, reading comprehension, that sort of stuff. And that kind of work, feels very similar, feels much closer to my day to day work as a software engineer, as a programmer, than the work that I did in my data structures and algorithms course. Right. Like, I think find myself thinking about syntax grammar, communication skills, more than I do about runtime of data sets. Not to say that I don't sometimes, but usually it's more in that sort of, like language arts area. And yeah, I think that's interesting. You know what, like, what does it mean? What happens in those classes when professors are trying to spin it elsewise, or, or they're overly excited about the pieces that are not language based?

Noah Gibbs: Yeah, I also tend to feel that you can get 10 or 15 years into a programming career and you can often get to the point where the difficulty of problems we encounter day to day is something you can just handle and keep going. By and large you can get to the point where you're adequate to the job. And based on the experience of, say, people who write novels for a living, I'm going to say it seems like you can write things for other humans in English for 40 or 50 years and not get to the point where you're just good enough at the job.

Tyler Williams: Yeah, that's that's for sure. There's definitely a have like a lower skill ceiling or so you know like a novelist can be a an exceptional novelist by the by a degree that a an exceptional programmer, perhaps like can't get that much further than a mediocre programmer. Right?

Noah Gibbs: Well, what I'd say is that as long as you're talking to the machine, there's a, there's a there's a low skill ceiling, there's exactly what you talk about. But then you remember that you're trying to talk to the machine as a separate constraint as you try and find the best way to talk to other people. And at that point, you're dealing with the part where deep talking to the machine is just not the hard part anymore. Because you hit the point where you're good enough at that, and you're never going to hit the point where talking to the other people is something you're just good enough at.

Tyler Williams: Yeah, absolutely. Absolutely.

Noah Gibbs: Cool. Well, thank you very much that I thought that was a great answer. Really several great answers chained one after the other. Thank you. We talked about big O. Big O is sort of the classic, the most famous. I expect that by the time I've recorded a lot of episodes of this I'm gonna have a lot of opinions of big O. Even if you ignore mine and I have I have a lot of opinions of big O, just myself. State machines were the other thing that in the lead up to this, you and I mentioned as a as a thing you had an interest in. Tell me about that. What do you think of state machines, and especially with a professional spin, you know, in your job, not just kind of as an abstract concept?

Tyler Williams: Yeah, absolutely. I love [state machines](https://en.wikipedia.org/wiki/Finite-state_machine). If you're listening to this, and you haven't done a lot of research into state machines, you haven't played with them, thought about them, and you're interested in computer science or you think you might be, I think they're a really good place to start. And so, and they were my favorite subjects in college when we got to them. So, you know, here's kind of what a state machine is. This is just like the Wikipedia definition, I pulled beforehand, because I think it's a good one. But a state machine is it's an abstract idea of a machine that can be in exactly one of a finite number of states at any given time. And that's specifically about a finite state machine. There are other variants on this, but that's, that's kind of like the typical one you'll be interested to in a computer science education is a finite state machine. And so the idea is that in response to some inputs, it gets to change from one state to another. And that's called a transition. And so you can actually just define a finite state machine, you could take pen and paper, and you could write a finite state machine, all you need to do is list its states, its initial state, and any inputs that trigger the transition. And so the classic example, is traffic lights, right? So in the US traffic lights, we have green, yellow and red lights on that traffic light. Green means go yellow is a warning that the light is about to change to red and that you should slow down. You know, I think that point's debatable depending on who you are and how you drive. But that's what that's the you know, that's what it means.

Noah Gibbs: That means red is coming.

Tyler Williams: It means red is coming. Yeah, that's that is maybe more precise and generalized so it means read is coming. And then red specifically means stop. And so in the US these traffic lights, they only ever go from green to yellow, yellow to red, and red to green, you're never going to get red to yellow, or green to go immediately to red. And so you could sit down with a pen and paper. And you could define the state machine that is a traffic light, you could say, here are the states: green, yellow, red, it starts, say it starts at green. I actually don't know where they start out when you boot them up. But you can say, hey, my traffic light is going to start at Green. And then you say, what are the inputs to move it? And you have a handful of choices here. I think often, I think in an easy example. It's time. So there's some timing function, every x number of seconds, the transition happens. And then of course, there's pressure plates and pedestrian buttons, that sort of stuff as well. So you can define the state machine on pen and paper. It gets really interesting when you apply it in computer science and you apply it in programming. And I think that, this is, you know, I think out of everything that I learned about in my computer science education. And granted, I didn't take operating systems. I didn't take compilers. Those are the two classes I missed. So perhaps I'm missing a really important thing. I think state machines are the most useful concept in day to day programming out of anything else I learned. And the reason being is that they, if you model your software, as a state machine, you get a lot of built in reliability. And I think that's true in both the back end and the front end. I want to talk about the front end, because I think that people who write UX software people who write presentational software, thinking a lot about like the front end of web browsers, HTML, CSS, and JavaScript, but also any mobile apps or other systems programming that has a graphics library.

Tyler Williams  
If you're building out UX, I think a lot of those folks are the ones who are left behind the most in conversations. about computer science. They're the people who get the most amount of ire for not having enough computer science in their heads or something. Or if that's not what's the problem, there's also perhaps many of them, like, just don't think they need it or don't think that there's anything for them in computer science. And I think that's because many computer scientists have been beating a drum for a long time saying, there's nothing for you here, like, leave this to us. We'll do it all on the back end. state machines are awesome for UX. They're amazing. And there's actually there's a really good library for managing state in. I've used it with react, I don't know if it's applicable to other frameworks or even sans front end framework. It's called [XState](https://xstate.js.org/). And so the idea is that you actually define the state of your application in XState and you say, here are the states and a really good simple example. I think, to sort of make this concrete is a think about, you know, menus, navigation bars that have toggles So a menu can be toggled open, it can be toggled closed, those are your two states. And there's an input, which is probably a hamburger button and perhaps an X button, right? Maybe it's also the Escape key or clicking outside of it, whatever it is, you've got a finite list of states open and closed. And you've got a finite list of events that change the state and have a transition. And so you can model, I think you can go from that example and think about a lot of different things on a web page. Think about accordions. Think about sliders, carousels, all these sorts of things. And this is really where, you know, when people build front end applications with React, Vue.js, Svelte, any number of these front end frameworks, you know, the one thing I listen to Shop Talk Show a lot, they're great. And one of the big things where they talked about you know, when do you reach for a framework? And the word's right there for us, for everyone... Is like when you have state. And it's like, right, like, that's when these things are really helpful. And so I think that it puts you in a great place to think about state machines. And I use them every day, I think about them all the time. And it just, it takes a lot of guesswork out of what might go wrong with your state. And I can think of, you know, there's a classic example of like, again, thinking about these navigations. And these menus is like, you got a button click, and it like, adds a class to the thing that makes it display or whatever. And it's like, oh, no, like, what if the class is already there? What do I do next? And so then you graduate from like adding and removing classes to the class list toggle, right? And like, but again, you're just you're basically talking about a state machine. And I think if people think about state machines, if they think about their UX, like a state machine, I think that it takes a lot of that guesswork out. And it gives you a really useful framework for understanding the work that you have to do. And I think there's some clear application In the backend as well or elsewhere in the stack thinking about, like, just yesterday, I was working with some problems with my Elasticsearch brew service. Totally borked, and. But like, it was nice to know that. So it was like, it was an unknown status in homebrew. And I was trying to turn it on, but it wouldn't go on because I thought it was already running. And then I would try and turn it off. But it wouldn't change it because it was already not running. But these ideas of like what states and so this is a thing where a state machine would have been really useful is like, there's no state for it to get into that you don't understand the inputs that could have got it to that state. And I think that's really useful for any sort of software that needs to be running in perpetuity, or running at a specific time.

Noah Gibbs: That makes sense. Something I will point out about both of the two points you just made. Both the whole when you've got something like the state of the running process. And that's potentially separate from what the system thinks about it. So you have two duplicate things that can be out of sync. And also, you mentioned front end programmers often kind of traditionally get the short end of the stick on state machines and computer science. One thing that those have in common and have in common with a lot of other places, is that my experience is state machines work the best and are the cleanest when there isn't a lot of extraneous state that you don't directly control. And while there's nothing magical about the back end that guarantees that you don't have state you don't control, the front end almost always has additional state you don't control. There are only a few places where you truly control almost everything. And they're basically all on the back end.

Tyler Williams: Yeah. Yeah, that makes a lot of sense. And I think, you know, thinking about the front end applications is it gets much more useful, like you said, the more clearly you can define that state and control it, the more direct application I think you're going to see. But there are things you know that menu like you can build a small state machine that doesn't need to encapsulate the entire application, right, your menu could just be the state machine. And you don't need to worry about extraneous stuff coming into that because like, that's your menu, nothing else just...

Noah Gibbs: Right, and you're talking about a bunch of habits that in my experience, you get slowly over time and with experience and by being burned by things, where you learn how to do that delicate dance, where you can draw a line around your stuff and say, This is my stuff and nobody else touches it. And this I control the state on because so many things where you expose the menu, you drop the menu, you've got a you know, thing that depends on the state of the DOM. And the state of the DOM is one of those things like the state of the database or the state of the hardware. It's a code phrase, that means there's a giant chunk of state that I am horrifyingly dependent on that I don't directly control. You can say I have a full state machine for how I poke the hardware. But in the end, the hardware is going to do what the hardware is going to do. You can have a full state machine for how you poke the database. But if if Postgres decides that it's in the middle of a vacuuming stage, and this thing is going to be locked, whether you meant it to be locked or not. You don't control it, you can't change it, Postgres did it. It affects whether you can do what you do. And all you can do is design your state machine very carefully to tiptoe around it.

Tyler Williams: Yeah, yeah, precisely. But yeah, I think state machines are awesome. And they're super fun, too, you know, there's another good application of state machines. And this was what really got me in college about them. I think my first introduction to state machines was in like my sophomore, or like late freshman year, just like intro to object oriented programming course. Right? And we built a [MUD](https://en.wikipedia.org/wiki/MUD), right, one of those classic text based adventure games. And those are great state machines, because they are right and it's like, you know, you think about each scene is like you are in a dungeon to your left is a hallway to your right is a staircase. The state machine is your state is in the dungeon, you have a transition you can have your input is go down the hallway or your input is go up the stairs and you transition into the next state and that was a really fun project to do we get to build, it was very creative. And those things are just, they're infinitely fun to me. I love them. I think they're super nerdy and geeky, and state machines are really good fit for that sort of thing. It's really good way to get your head around them. And it also like, you know, they're not that scary because if you can build sort of an adventure game using a state machine, I think you can both understand it well, but like get a really solid look, you can understand that easily. But again, a nuanced understanding of it in a way that may be a contrived example, like a like a stoplight, like programming a stoplight program, maybe isn't going to give you a rich understanding of like those transitions and the applications, but making some sort of adventure game, I think you will really get a full grasp of what state machines are, how to use them and their applications.

Noah Gibbs: Yeah, well, the problem with a with a stoplight is the odds of you getting to actually deploy it on a street corner somewhere are basically zero. You can design it in as much you know, detail as you want, but they're not going to let you put it somewhere. And so you can't use it, which means you'll never really first-person understand where you messed it up. One of the joys of a MUD is that since these things are sort of physical, since you're making things that are supposed to seem physical, you can wander through it and figure out where you messed it up. And you can go in and make fixes and improve things. And yeah, it's really satisfying to use the thing that you actually designed, and it also suddenly shows you a lot of bad habits you didn't know you had. But if you never use the results of your work, you never see them.

Tyler Williams: Yeah, absolutely. So cool. Let's see.

Noah Gibbs: So I feel like we already talked a fair bit about big O notation, but in some of your kind of early pre show notes, stuff you'd thought about. You mentioned again, you know, big O notation.  Do you want to be want to talk a little more about that stuff? Do you feel like we already covered it or...?

Tyler Williams: Yeah, there. There was one point I was hoping we'd get the opportunity to go revisit when we're talking about big O and I think we touched on it briefly. Big O has become sort of the flashpoint in a lot of ways at data structures and algorithms generally. But I think that this is where people are thinking about the what feels often like the opposition of computer science and day to day programming. And it comes out a lot. And I think the reason it's a flashpoint, is because we talked a little bit about sort of like, perhaps, like gatekeeping procedures, but they come up in interviews, right, or they come up in what people think about tech interviews, sort of the big Silicon Valley that like is dictating a lot of other practices out there. But it's [LeetCode](https://leetcode.com/), right? Like that's the answer, like LeetCode, the code problems, Cracking the Coding, interview, all that sort of stuff that has leaked out into hiring processes, has has put up data structures and algorithms and big O notation as sort of a subset of that has put that up as the barrier to being a programmer. That is the thing you got to conquer. And it is also kind of weird because or it can feel like a juxtaposition. Because there are many interviews out there that are not using data structures and algorithms in that day to day work for the job they're hiring for, but they require you to get a specific score on these LeetCodes to do it. And I think things are changing a little bit. I think that some employers are starting to value not so much the answer or the speed of the answer, but they want to see people reason about it. And so this is this is what I this is how I feel about data structures, algorithms, bigo, and interviews and this sort of gap. I think that data structures and algorithms are foundational. I think they're fun. I think people ought not to be afraid of them, because they're cool to learn about and they're fun to do. They're also a good way to learn, like standard libraries of the programming language you're using. When I was like learning Ruby, I did a ton of LeetCode problems in Ruby so I could learn like fun Ruby tricks to do stuff right like mapping arrays. I think it's a really great place to like learn the standard library of a language. It's easy to say that while I have a job, it's harder when when you need a job to live. And you feel like data structures and algorithms are the thing that's in your way to getting paid so you can survive. That's a terrifying position. And it's such a disservice to that field of study that like we've made it this huge, scary thing. It's cool to see employers who are saying let's get this right and more, I want you to walk through the problem because that's what data structures and algorithms are really good for. They are really great demonstration of a person's ability or willingness to look at an abstract, and, like very poorly defined problem. I think that's a characteristic of a lot of these is that the problem is poorly defined. And you know, you can watch someone walk through a poorly defined problem and arrive at an answer and then evaluate the quality of that answer. And that is in many ways I think that is a day to day programming task across front end, back end, all sorts of applications of software is unclear requirements, coming up with and walking through it coming up with an answer and like evaluating how good the answer is. And if you can get good at those reasoning skills, you know, I think if you use data structures, algorithms, big O notation, as they practice ground for that, because like, that's the thing is, in lieu of the actual project, you don't have a lot of source material. There is a ton of source material when it comes to leak code. So it's a great place as a practice ground to like, practice those specific skills. But, again, the problem is that, like, learning that is, is different than learning how to program. It's different than than learning those day to day, like how to hook up your API to something. And it's, it's a big game in pattern recognition. Right? And so you really just have to be bad at them for a while. Give an honest go at it, but like you just got to be bad at the problems right? Like that's, that's how like, I've gotten better at this is you give an honest shot at every problem. You're super bad at it can't get it, maybe you can get a really bad answer to it. Then you read the answer to it, you get better at it and you sort of improve. But I think that like hiring practices have weaponized this kind of area of computer science, especially against career changers who have not had, it's not that they don't have critical reasoning skills. Like if you don't understand LeetCode problems, if you're struggling with data structures and algorithms, it's not because there's some magic you your brain doesn't have. It's not because you can never be good at it. It's just because it's it's a very specific kind of pattern that perhaps you haven't looked at a whole bunch. And that's a really like, high bar for hiring teams to put in front of people trying to get a job and it helps them. You know, I think for hiring in tech, the incentive is often to get a ton of false negatives, because they tend to get more applicants than they can service. And you know, the cost of interviewing is low. The cost of an incorrect, of a bad fit is really high. So like, it's in their interest to say no to more people than they ought to, rather than to say yes to more people than they ought to. And so that's, you know, a competing interest there. But yeah, I think bigger data structures, algorithms, super important, relevant to day to day in that they are sometimes a proxy for defining problems and getting to a good answer. But they are not one to one. And I don't think that like a person's unfamiliar, but they require familiarity. And a person's familiarity with data structures and algorithms is not a like, good indicator of their ability to become familiar with them and to become good at defining problems and to become good at solving them. So yeah, I think that's kind of the state of I think that's a big piece of broken tech hiring right now is a huge flashpoint. And that's what people think about and I wish they didn't Because I wish that it felt more approachable. I wish there were better resources out there for people to learn, friendlier resources out there, and friendlier people talking about it.

Noah Gibbs: There's a wonderful, cranky old programmer that I read and listen to sometimes, [Reginald Braithwaite](https://raganwald.com/). He goes by Raganwald online in a bunch of places. And one of the joys of him being even older than I am, is he brings up a lot of things like that you need you used to need to have good handwriting as a standard part of the job application, like you were expected to submit writing samples. And if you didn't have good handwriting with a fountain pen, you were generally considered unemployable in the better and more desirable jobs. And he points out that a lot of what we do is like that, you know, when you talk about big O notation or algorithms and how there's there's almost this phobic reaction from people who are in these high stakes situations. They can't necessarily get a job without them. It's kind of the worst way to learn this basically good thing. I keep flashing back to handwriting in my head which is a great example like if you've ever just played around with a fountain pen, they're a lot of fun. But if you had to carefully reproduce an exact kind of writing in order to feed your family, they would probably be a lot harder to just mess around with in your spare time.

Tyler Williams: Yeah, a lot scarier. Yeah. Now that's, that's really interesting. I would be unemployable. My handwriting is atrocious.

Noah Gibbs: Likewise.

Tyler Williams: Right. I think that there is overall, we've talked about this podcast, the useful bits, there's a lot of them. You know, I mean, it like, I don't think that you can separate Computer Science from programming entirely. I do think that they are two different things. And I think that the day to day work is not the same as the formal education. There was one other piece that I wanted to bring up and say, and just like, as a person who has lived this, you know, I spent a lot of time in a formal Computer Science Program didn't complete it. So happy to concede that I don't know what a full one looks like. Perhaps, perhaps there would have been some magic in operating systems, compilers and my capstone project that would have somehow turned my brain into something different. I don't think that's the case. But I'm willing to hear someone tell me that that's the case. A computer science education, extremely useful and relevant to people who want to be programmers. Other kinds of Education's like a history degree, also really relevant and useful. Like I have used my communication skills, my research skills, my categorization skills. in history, we talk a lot you brought up the idea of a novel, The writing a novel, right?

We talk a lot about scope, and storytelling in history. And so when you sit set out to do a real piece of history work, a historical research paper book, something like basically think as a secondary source, something that's not a primary historical source, but something like a textbook, you do a lot. You spend a lot of time it's called historiography. spend a lot of time talking about the geography of the area of where you will be researching that timeframe. Why are you choosing that timeframe? The people, the types of stuff courses you will work with. This is requirements gathering and software. It's a very similar process, and it's extremely relevant. And so computer science is gonna, I think, a formal Computer Science Education gives you a great breadth of understanding of relevant topics in computing and programming. And, of course, they're very directly related, it's always going to help not having it, but having some other kind of education or life experience, something that has taught you to like think critically, think about systems, work with fuzzy problems and come up with concrete answers to them. I think that that is also going to serve you well. And you may be missing a couple things, you know, I think computer science education's, they're going to give you a shortcut to understanding optimization and understanding that sort of work right, like you will, you will get it faster. I think that that's the case because you will have more exposure to it.

But I don't think that you can't get it. If you've ever had that education. That's a that's really I think the most important point for me when I think about the useful There's a ton of them there. But they're not. I don't think they're prerequisites to being a good programmer, if you care about being good at that.

Noah Gibbs: Yeah, I mean, put it this way, I've got degrees in computer science and mathematics. And I'll say mathematics is something you can teach yourself if you keep at it. And I've got to say, the difference in you know how hard it is to teach yourself the programming versus how hard to have somebody else teach it to you versus mathematics. There's no contest. Mathematics is just harder to pick up on your own. Having someone who already understands it, you know, in a group setting is just more needed by mathematics. And yet, you can pick that up on your own, you can go out and do that. Programming is not as much harder to do on your own there. The other thing just because you brought it up a little bit ago, I did take operating systems classes in college that was that was one CMU was good at. And I while I didn't take their compilers class, I did work with the [CMU Common Lisp](https://www.cons.org/cmucl/) compilers team in my [part time job on a compiler](http://www.cs.cmu.edu/afs/cs/project/gwydion/docs/htdocs/gwydion/). So I think the experience was was effectively similar. They are good tricks. They are tricks that are hard to completely replace. But they're not any different from the kind of tricks that you already picked up. But they're not different from the kind of trick you got by learning about algorithms and how to analyze them or, you know, pointers. I don't know if you did pointers, but pointers are another kind of thing where, if you understand that they teach you something, but you can learn it on your own. And it's not indispensable. It's just a good trick.

Tyler Williams: Yeah. I've got a question that hopefully is useful for listeners. If not, we can cut this out too. So I was looking at my master's coursework, and I was actually hoping that there would be operating systems or compilers there, there will not be in software engineering, as opposed to a master's in CS. I wanted to self learn a little bit about those things. And this is the thing like I wish I this is what I'm missing from that formal education. I can Google how to learn about compilers, too much noise, I really need a good signal. So if you were to recommend someone, you know those two topics in particular, because I'm personally missing them. I'm also really interested in them.  Where does As a person start to learn about those two things?

Noah Gibbs: I'm going to give you a couple of different starting points, and you can decide which ones are useful to you. There is a great [Steve Yegge blog post](http://steve-yegge.blogspot.com/2007/06/rich-programmer-food.html), which probably counts as a short book, because it's the same length as all his other blog posts. About compilers. And he has a wonderful, a wonderful section at the beginning, where he where he sets up the bowling pins. And he says, how would you do this? How would you do this? How would you do this? And it gives a variety of problems that are clearly standard classic, write a compiler to solve problems. And then he gives you a full set of answers, none of which involve writing a compiler, because it's Steve Yegge. And he's mostly right on that. Nonetheless, if you know how to write compilers, then you know another solution to all of these things, some of which are better than the solutions, he suggests, and at least some ways. The Steve Yegge blog post is surprisingly educational in the sense that if you want to look at a bunch of problems and say, oh, right, a compiler is not just a computer language compiler. It's not that it has to parse you know, Perl or C++. It can parse anything. Then do a transformation on it. And so that's a good way to kind of get a feel for it. And you will end that blog post thinking, Okay, now I just need to learn the real secret and the real essence of how these steps work. And what a good practical part time job in compilers and interpreters will teach you or reading through a bunch of source code for it is that there are no secret tricks, those things you're looking for. Mostly they are they are the most boring pedestrian things you can imagine. And there are a few tiny little tweaks, but they're little tweaks. They're things like a really good compiler suite that does a massive number of optimizations, does this trick where it parses the representation once at the beginning, and then it doesn't convert it to text or anything at the end. It just operates on that same representation as much as possible without converting back and forth. In other words, the tricks all sound really boring because they are. Some of them are good, but they're all really boring.

Tyler Williams: Yeah, that's super exciting. Thank you. Yeah.

Noah Gibbs: Yeah, and similarly with operating systems which are hard to learn about. Generally what you want to do is find a good reference on Unix not because that's the operating system you want, but because it is the only operating system that was written in a well documented open way that you could then go and find out about and so everyone that writes an operating system starts by studying Unix.

Tyler Williams: That makes plenty of sense. Yeah, I think I've got the but classic book on that which I've never opened. But if you can get the one that everyone reads like that first manual, the white with blue text,

Noah Gibbs: Is that the Tanenbaum one or a different one?

Tyler Williams  
 Yeah, I think so. Yeah.

Noah Gibbs  
[Tanenbaum has the standard operating systems book](https://www.amazon.co.uk/Modern-Operating-Systems-Andrew-Tanenbaum/dp/013359162X). He's also got a [really good networking book](https://www.amazon.co.uk/Computer-Networks-Andrew-S-Tanenbaum/dp/0132126958/ref=sr_1_4). But yeah, a lot of it is it's it's not that everything is Unix. It's that everyone started on Unix and wrote these things as a reaction to Unix. It's the same way that Python and Ruby are very, very different from each other. But once you understand what Perl looks like, you understand they're both reactions to Perl.

Tyler Williams  
That is the case. I have like seen. It's funny. I when I started learning Python in middle school, Perl was like, the thing like I almost learned Perl instead, right? Because I had, I had one friend who also who knew how to program. And he knew, and he like wrote, like code in both of those languages. And I was like, hmmm... Python.

Noah Gibbs  
Well, and that's what it's for. Right? Python was people who looked at Perl and went, I like the scripting idea, and I hate everything else about the one scripting language that exists.

Tyler Williams  
Yeah, absolutely. Awesome. Well, I think yeah, that about covers it. For me. This has been great.

Noah Gibbs  
Well, usually I would ask you, you know what you're what you're planning to do to improve your skills, but you're just about to drop into a you know, finishing your undergrad degree and then a master's degree. So I think you've already got that one covered.

Tyler Williams  
Yeah, working on it. I will be reading [Mastering Software Technique](https://software-technique.com) during a break. I'm excited to actually get into it. And yeah, a lot of focus on school.

Noah Gibbs  
Yeah, if you love it, if you hate it, if you try it and it works. You try it and it doesn't work. I want to hear all those things of course, you know. And for the record, even if you hate it, you're totally allowed to shout that from the rooftops.

Tyler Williams  
Sure. Will do.

Noah Gibbs  
Awesome. Cool. Well, thank you very much. Let's see, pretend that this this podcast goes viral and everybody loves everything that you said. And this is a Twitter thread. The next thing would be to post your SoundCloud. What's your SoundCloud?

Tyler Williams: Yeah, so I do freelance work as Ogden studios. I've got a website, it is [Ogden Studios, all one word dot XYZ](https://ogdenstudios.xyz/). Sometimes that throws people off if they go for the dot-com. Ogden studios XYZ I do freelance open source stuff there. That's where I keep a blog. And that's probably the best place to get me. I'm [also on Twitter](https://twitter.com/tylerwilliamsct) a bunch and that's just Tyler Williams. C as in cat, T as in Tyler Tyler Williams, Connecticut. That's my handle there and I'm pretty much I'm very online so you can find me those two places. But I will be very busy with school. So I think that's, that's where I'll be for the next four, four years.

Noah Gibbs: Excellent. Well, thank you very much. It's been a been a great pleasure to have you here and your answers. were wonderful. Thank you very much. Yeah,

Tyler Williams: looking forward to hearing it. Cool.
